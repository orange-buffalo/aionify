# Internationalization (i18n) Guide

This guide explains how to work with translations in Aionify.

## Overview

Aionify uses [react-i18next](https://react.i18next.com/) for internationalization on the frontend. The application currently supports:

- **English (en)** - Default language
- **Ukrainian (uk)** - Secondary language

## Supported Languages

Users can select their preferred language from the profile settings page. The application will:

1. Display the UI in the selected language
2. Store the preference in the browser's localStorage
3. Remember the preference across sessions
4. Detect browser language on first visit (if supported)

## Translation Files

Translation files are located in `/frontend/src/lib/i18n.ts`. Each language has a complete translation object with the following structure:

```typescript
const resources = {
  en: {
    translation: {
      login: { /* login page translations */ },
      settings: { /* settings page translations */ },
      portal: { /* portal page translations */ },
      nav: { /* navigation translations */ },
      languages: { /* language names */ },
      validation: { /* error messages */ },
      common: { /* common phrases */ }
    }
  },
  uk: {
    // Ukrainian translations with the same structure
  }
}
```

## Adding Translations

### 1. Add Translation Keys

When adding new UI text, add both English and Ukrainian translations to `i18n.ts`:

```typescript
const resources = {
  en: {
    translation: {
      myNewSection: {
        title: "My New Section",
        description: "This is a description"
      }
    }
  },
  uk: {
    translation: {
      myNewSection: {
        title: "Моя нова секція",
        description: "Це опис"
      }
    }
  }
}
```

### 2. Use Translations in Components

Import and use the `useTranslation` hook in your React components:

```typescript
import { useTranslation } from "react-i18next"

export function MyComponent() {
  const { t } = useTranslation()
  
  return (
    <div>
      <h1>{t("myNewSection.title")}</h1>
      <p>{t("myNewSection.description")}</p>
    </div>
  )
}
```

### 3. Translations with Variables

For dynamic content, use interpolation:

```typescript
// In i18n.ts
welcome: "Welcome, {{name}}!"

// In component
{t("welcome", { name: userName })}
```

## Language Detection Flow

1. **On Login**: The server returns the user's preferred language code, which is stored in localStorage and the UI switches to that language
2. **On Page Load**: The application checks localStorage for saved language preference
3. **Browser Detection**: If no preference is saved, it detects the browser language and uses it if supported
4. **Fallback**: If the browser language is not supported, English is used as the default

## API Error Messages

The frontend translates API error messages using error codes returned by the backend. To add translation for a new API error:

1. Add the error code constant to the backend error response
2. Add the translation for the error code to the translation files under `errorCodes` section
3. The frontend will automatically translate the error using the `translateErrorCode` function

Example:

**Backend (Kotlin):**
```kotlin
Response.status(Response.Status.BAD_REQUEST)
    .entity(ProfileErrorResponse("Invalid locale format", "INVALID_LOCALE"))
    .build()
```

**Frontend (TypeScript translation files):**
```typescript
errorCodes: {
  INVALID_LOCALE: "Invalid locale format", // English
  // or
  INVALID_LOCALE: "Невірний формат локалі", // Ukrainian
}
```

The `translateErrorCode` helper function in `i18n.ts` will automatically translate the error code to the user's language.

## Testing Translations

### Manual Testing

1. Start the application: `./gradlew quarkusDev`
2. Navigate to the profile settings page
3. Change the language to Ukrainian
4. Verify that all UI text is translated
5. Refresh the page and verify the language persists
6. Log out and log back in to verify language is restored

### Playwright Tests

Translation functionality is covered by comprehensive Playwright tests in `I18nPlaywrightTest.kt`. These tests verify:

- Language detection on initial page load
- Language switching in profile settings
- Language persistence across page reloads
- Translation of validation errors
- Translation of API error messages

Run i18n tests with:
```bash
./gradlew test --tests "io.orangebuffalo.aionify.I18nPlaywrightTest"
```

## Adding a New Language

To add support for a new language:

1. **Add translations**: Add a new language object to the `resources` in `i18n.ts`:
   ```typescript
   const resources = {
     en: { /* existing */ },
     uk: { /* existing */ },
     fr: { // New French translation
       translation: { /* complete translation */ }
     }
   }
   ```

2. **Update backend**: Add the language code to the `SUPPORTED_LANGUAGES` set in `UserResource.kt`:
   ```kotlin
   private val SUPPORTED_LANGUAGES = setOf("en", "uk", "fr")
   ```

3. **Update UI**: Add the language to the `LANGUAGES` array in `ProfilePanel.tsx`:
   ```typescript
   const LANGUAGES = [
     { code: "en", name: "English" },
     { code: "uk", name: `Ukrainian (${ISO6391.getNativeName("uk")})` },
     { code: "fr", name: "French" }
   ]
   ```

4. **Add translations for language names**: Update the `languages` section in both English and the new language:
   ```typescript
   languages: {
     en: "English",
     uk: "Ukrainian (Українська)",
     fr: "French (Français)"
   }
   ```

5. **Test**: Create or update Playwright tests to cover the new language

## Best Practices

1. **Keep translations in sync**: When adding new features, always add translations for all supported languages at the same time
2. **Use descriptive keys**: Use hierarchical keys that describe the context (e.g., `settings.profile.title` instead of just `title`)
3. **Avoid hardcoded strings**: Never use hardcoded English strings in components - always use translation keys
4. **Test thoroughly**: Test language switching and verify all text is translated properly
5. **Handle plurals**: Use i18next plural features for text that changes based on count
6. **Context matters**: Provide context in translation keys to help translators understand usage
7. **Use error codes**: Always use error codes in API responses for translation, not free-text error messages
